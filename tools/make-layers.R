

# if(!exists("_COMMON_"))
envir::attach_eval(envir::include("tools/common.R"))

# TODO: don't export Layer, InputLayer

layers <- names(keras$layers) %>%
  # setdiff(c("Layer", "InputLayer")) %>%
  grep("GlobalAvgPool.D", ., value = TRUE, invert = TRUE) %>%  # alias for GlobalAveragePooling
  grep("GlobalMaxPool.D", ., value = TRUE, invert = TRUE) %>%  # alias for GlobalMaxPooling1D
  {.[order(map_chr(., \(nm) py_repr(keras$layers[[nm]])))]} %>%
  sort() %>%
  purrr::set_names() %>%
  lapply(function(nm) {
  obj <- keras$layers[[nm]]

  if(obj$`__name__` == "Input")
    return(obj)

  if(is_layer_class(obj))
    return(obj)


  if (!nm %in% c(
    "add",
    "average",
    "concatenate",
    "deserialize",
    "dot",
    # "experimental",
    "InputSpec",
    "maximum",
    "minimum",
    "multiply",
    # "serialize",
    "subtract"
  ))
  message("skipping ", nm)
  NULL
}) %>%
  keras:::drop_nulls()

mk_layer_activation_selu <- function() {
  roxygen <- r_doc_from_py_fn(keras$activations$selu) %>%
    c("#' @inheritDotParams layer_activation")

  fn <- function(object, ...) {
    layer_activation(object, activation = "selu", ...)
  }
  fn %<>% rlang::zap_srcref()
  str_flatten(c(roxygen,
                "layer_activation_selu <-",
                deparse(fn)),
              collapse = "\n")
}

layers %>%
  lapply(new_layer_wrapper) %>%
  unlist() %>%
  c("## Autogenerated. Do not modify manually.", .) %>%
  c(., mk_layer_activation_selu()) %>%
  str_flatten(collapse = "\n\n\n") %>%
  strsplit(., "\n") %>% .[[1]] %>%
  trimws("right") %>%
  str_flatten("\n") %>% {
    while (nchar(.) !=
           nchar(. <- gsub("#'\n#'\n", "#'\n", ., fixed = TRUE))) {}

    # while (nchar(.) !=
    #        nchar(. <- gsub("\n\n\n", "\n\n", ., fixed = TRUE))) {}
    .
  } %>%
  writeLines("R/layers.R")


# #' @param sparse
#' If TRUE, calling this layer returns a `tf.SparseTensor`. If FALSE,
#' the layer returns a dense `tf.Tensor`. For an entry with no features in
#' a sparse tensor (entry with value 0), the embedding vector of index 0 is
#' returned by default.

# TODO: backtick TRUE, FALSE
#
# TODO: MultiHeadAttention: docs trunctated at examples
# keras$layers$MultiHeadAttention %>% get_doc() -> z
# z$many_returns[[1]]$description |> cat()
# # strsplit on "Examples:", process examples separately.
# TODO: update docs based on args - crosscheck roxygen params and formals

# TODO: manage axis transition 0 -> 1 based
#   - list all 0-based locations
#   - communicate transition
#
# styler::style_file("R/layers.R")



# print.r_py_wrapper2 <- function(x, ...) {layer_random_brightness
#   try(clipr::write_clip(x))
#   cat(x)
# }



# new_layer_wrapper(keras$layers$Embedding)
#
# new_layer_wrapper(keras$layers$BatchNormalization)

## example usage:
# new_layer_wrapper(keras$layers$TextVectorization)
# new_layer_wrapper(keras$layers$DepthwiseConv1D)
# new_layer_wrapper(keras$layers$UnitNormalization)
# new_layer_wrapper(keras$layers$Attention)
# new_layer_wrapper(keras$layers$Discretization)
# new_layer_wrapper(keras$layers$GaussianDropout) |> print()
# new_layer_wrapper(keras$layers$GaussianNoise) |> print()
# new_layer_wrapper(keras$layers$IntegerLookup) |> print()
# new_layer_wrapper(keras$layers$Normalization) |> print()
# new_layer_wrapper(keras$layers$StringLookup) |> print()

