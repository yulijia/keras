% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers.R
\name{layer_locally_connected_1d}
\alias{layer_locally_connected_1d}
\title{Locally-connected layer for 1D inputs}
\usage{
layer_locally_connected_1d(
  object,
  filters,
  kernel_size,
  strides = 1L,
  padding = "valid",
  data_format = NULL,
  activation = NULL,
  use_bias = TRUE,
  kernel_initializer = "glorot_uniform",
  bias_initializer = "zeros",
  kernel_regularizer = NULL,
  bias_regularizer = NULL,
  activity_regularizer = NULL,
  kernel_constraint = NULL,
  bias_constraint = NULL,
  implementation = 1L,
  ...
)
}
\arguments{
\item{filters}{Integer, the dimensionality of the output space (i.e. the
number of output filters in the convolution).}

\item{kernel_size}{An integer or list of a single integer, specifying
the length of the 1D convolution window.}

\item{strides}{An integer or list of a single integer, specifying the
stride length of the convolution.}

\item{padding}{Currently only supports \code{"valid"} (case-insensitive). \code{"same"}
may be supported in the future. \code{"valid"} means no padding.}

\item{data_format}{A string, one of \code{channels_last} (default) or
\code{channels_first}. The ordering of the dimensions in the inputs.
\code{channels_last} corresponds to inputs with shape \verb{(batch, length, channels)} while \code{channels_first} corresponds to inputs with shape
\verb{(batch, channels, length)}. When unspecified, uses
\code{image_data_format} value found in your Keras config file at
\verb{~/.keras/keras.json} (if exists) else 'channels_last'.
Defaults to 'channels_last'.}

\item{activation}{Activation function to use. If you don't specify anything,
no activation is applied (ie. "linear" activation: \code{a(x) = x}).}

\item{use_bias}{Boolean, whether the layer uses a bias vector.}

\item{kernel_initializer}{Initializer for the \code{kernel} weights matrix.}

\item{bias_initializer}{Initializer for the bias vector.}

\item{kernel_regularizer}{Regularizer function applied to the \code{kernel} weights
matrix.}

\item{bias_regularizer}{Regularizer function applied to the bias vector.}

\item{activity_regularizer}{Regularizer function applied to the output of the
layer (its "activation")..}

\item{kernel_constraint}{Constraint function applied to the kernel matrix.}

\item{bias_constraint}{Constraint function applied to the bias vector.}

\item{implementation}{implementation mode, either \code{1}, \code{2}, or \code{3}. \code{1} loops
over input spatial locations to perform the forward pass. It is
memory-efficient but performs a lot of (small) ops.  \code{2} stores layer
weights in a dense but sparsely-populated 2D matrix and implements the
forward pass as a single matrix-multiply. It uses a lot of RAM but
performs few (large) ops.  \code{3} stores layer weights in a sparse tensor
and implements the forward pass as a single sparse matrix-multiply.
How to choose:
\code{1}: large, dense models,
\code{2}: small models,
\code{3}: large, sparse models,  where "large" stands for large
input/output activations (i.e. many \code{filters}, \code{input_filters},
large \code{input_size}, \code{output_size}), and "sparse" stands for few
connections between inputs and outputs, i.e. small ratio
\code{filters * input_filters * kernel_size / (input_size * strides)},
where inputs to and outputs of the layer are assumed to have
shapes \verb{(input_size, input_filters)}, \verb{(output_size, filters)}
respectively.  It is recommended to benchmark each in the setting
of interest to pick the most efficient one (in terms of speed and
memory usage). Correct choice of implementation can lead to
dramatic speed improvements (e.g. 50X), potentially at the expense
of RAM.  Also, only \code{padding="valid"} is supported by
\code{implementation=1}.}

\item{...}{standard layer arguments.}
}
\description{
Locally-connected layer for 1D inputs
}
\details{
The \code{LocallyConnected1D} layer works similarly to
the \code{Conv1D} layer, except that weights are unshared,
that is, a different set of filters is applied at each different patch
of the input.

Note: layer attributes cannot be modified after the layer has been called
once (except the \code{trainable} attribute).
}
\seealso{
\itemize{
\item \url{https://keras.io/api/layers}
}
}
