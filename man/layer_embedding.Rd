% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers.R
\name{layer_embedding}
\alias{layer_embedding}
\title{Turns positive integers (indexes) into dense vectors of fixed size}
\usage{
layer_embedding(
  object,
  input_dim,
  output_dim,
  embeddings_initializer = "uniform",
  embeddings_regularizer = NULL,
  activity_regularizer = NULL,
  embeddings_constraint = NULL,
  mask_zero = FALSE,
  input_length = NULL,
  sparse = FALSE,
  ...
)
}
\arguments{
\item{input_dim}{Integer. Size of the vocabulary,
i.e. maximum integer index + 1.}

\item{output_dim}{Integer. Dimension of the dense embedding.}

\item{embeddings_initializer}{Initializer for the \code{embeddings}
matrix (see \code{keras.initializers}).}

\item{embeddings_regularizer}{Regularizer function applied to
the \code{embeddings} matrix (see \code{keras.regularizers}).}

\item{embeddings_constraint}{Constraint function applied to
the \code{embeddings} matrix (see \code{keras.constraints}).}

\item{mask_zero}{Boolean, whether or not the input value 0 is a special
"padding" value that should be masked out. This is useful when using
recurrent layers which may take variable length input. If this is
\code{TRUE}, then all subsequent layers in the model need to support masking
or an exception will be raised. If mask_zero is set to TRUE, as a
consequence, index 0 cannot be used in the vocabulary (input_dim should
equal size of vocabulary + 1).}

\item{input_length}{Length of input sequences, when it is constant.
This argument is required if you are going to connect
\code{Flatten} then \code{Dense} layers upstream
(without it, the shape of the dense outputs cannot be computed).}

\item{sparse}{If TRUE, calling this layer returns a \code{tf.SparseTensor}. If FALSE,
the layer returns a dense \code{tf.Tensor}. For an entry with no features in
a sparse tensor (entry with value 0), the embedding vector of index 0 is
returned by default.}

\item{...}{standard layer arguments.}
}
\description{
Turns positive integers (indexes) into dense vectors of fixed size
}
\details{
e.g. \verb{[[4], [20]] -> [[0.25, 0.1], [0.6, -0.2]]}

This layer can only be used on positive integer inputs of a fixed range. The
\code{tf.keras.layers.TextVectorization}, \code{tf.keras.layers.StringLookup},
and \code{tf.keras.layers.IntegerLookup} preprocessing layers can help prepare
inputs for an \code{Embedding} layer.

This layer accepts \code{tf.Tensor}, \code{tf.RaggedTensor} and \code{tf.SparseTensor}
input.

Example:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> model = tf.keras.Sequential()
>>> model.add(tf.keras.layers.Embedding(1000, 64, input_length=10))
>>> # The model will take as input an integer matrix of size (batch,
>>> # input_length), and the largest integer (i.e. word index) in the input
>>> # should be no larger than 999 (vocabulary size).
>>> # Now model.output_shape is (NULL, 10, 64), where `NULL` is the batch
>>> # dimension.
>>> input_array = np.random.randint(1000, size=(32, 10))
>>> model.compile('rmsprop', 'mse')
>>> output_array = model.predict(input_array)
>>> print(output_array.shape)
(32, 10, 64)
}\if{html}{\out{</div>}}

Input shape:
2D tensor with shape: \verb{(batch_size, input_length)}.

Output shape:
3D tensor with shape: \verb{(batch_size, input_length, output_dim)}.

\strong{Note on variable placement:}
By default, if a GPU is available, the embedding matrix will be placed on
the GPU. This achieves the best performance, but it might cause issues:
\itemize{
\item You may be using an optimizer that does not support sparse GPU kernels.
In this case you will see an error upon training your model.
\item Your embedding matrix may be too large to fit on your GPU. In this case
you will see an Out Of Memory (OOM) error.
}

In such cases, you should place the embedding matrix on the CPU memory.
You can do so with a device scope, as such:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{with tf.device('cpu:0'):
  embedding_layer = Embedding(...)
  embedding_layer.build()
}\if{html}{\out{</div>}}

The pre-built \code{embedding_layer} instance can then be added to a \code{Sequential}
model (e.g. \code{model.add(embedding_layer)}), called in a Functional model
(e.g. \code{x = embedding_layer(x)}), or used in a subclassed model.
}
\seealso{
\itemize{
\item \url{https://keras.io/api/layers}
}
}
