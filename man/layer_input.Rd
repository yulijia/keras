% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers.R
\name{layer_input}
\alias{layer_input}
\title{\code{Input()} is used to instantiate a Keras tensor}
\usage{
layer_input(
  shape = NULL,
  batch_size = NULL,
  name = NULL,
  dtype = NULL,
  sparse = NULL,
  tensor = NULL,
  ragged = NULL,
  type_spec = NULL,
  ...
)
}
\arguments{
\item{shape}{A shape list (integers), not including the batch size.
For instance, \verb{shape=(32,)} indicates that the expected input
will be batches of 32-dimensional vectors. Elements of this list
can be NULL; 'NULL' elements represent dimensions where the shape is
not known.}

\item{batch_size}{optional static batch size (integer).}

\item{sparse}{A boolean specifying whether the placeholder to be created is
sparse. Only one of 'ragged' and 'sparse' can be TRUE. Note that,
if \code{sparse} is FALSE, sparse tensors can still be passed into the
input - they will be densified with a default value of 0.}

\item{tensor}{Optional existing tensor to wrap into the \code{Input} layer.
If set, the layer will use the \code{tf.TypeSpec} of this tensor rather
than creating a new placeholder tensor.}

\item{ragged}{A boolean specifying whether the placeholder to be created is
ragged. Only one of 'ragged' and 'sparse' can be TRUE. In this case,
values of 'NULL' in the 'shape' argument represent ragged
dimensions.  For more information about RaggedTensors, see
\href{https://www.tensorflow.org/guide/ragged_tensor}{this guide}.}

\item{type_spec}{A \code{tf.TypeSpec} object to create the input placeholder from.
When provided, all other args except name must be NULL.}

\item{...}{standard layer arguments.}

\item{**kwargs}{deprecated arguments support. Supports \code{batch_shape} and
\code{batch_input_shape}.}
}
\description{
\code{Input()} is used to instantiate a Keras tensor
}
\details{
A Keras tensor is a symbolic tensor-like object, which we augment with
certain attributes that allow us to build a Keras model just by knowing the
inputs and outputs of the model.

For instance, if \code{a}, \code{b} and \code{c} are Keras tensors,
it becomes possible to do:
\verb{model = Model(input=[a, b], output=c)}

A \code{tensor}.

Example:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{# this is a logistic regression in Keras
x = Input(shape=(32,))
y = Dense(16, activation='softmax')(x)
model = Model(x, y)
}\if{html}{\out{</div>}}

Note that even if eager execution is enabled,
\code{Input} produces a symbolic tensor-like object (i.e. a placeholder).
This symbolic tensor-like object can be used with lower-level
TensorFlow ops that take tensors as inputs, as such:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{x = Input(shape=(32,))
y = tf.square(x)  # This op will be treated like a layer
model = Model(x, y)
}\if{html}{\out{</div>}}

(This behavior does not work for higher-order TensorFlow APIs such as
control flow and being directly watched by a \code{tf.GradientTape}).

However, the resulting model will not track any variables that were
used as inputs to TensorFlow ops. All variable usages must happen within
Keras layers to make sure they will be tracked by the model's weights.

The Keras Input can also create a placeholder from an arbitrary
\code{tf.TypeSpec}, e.g:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{x = Input(type_spec=tf.RaggedTensorSpec(shape=[NULL, NULL],
                                        dtype=tf.float32, ragged_rank=1))
y = x.values
model = Model(x, y)
}\if{html}{\out{</div>}}

When passing an arbitrary \code{tf.TypeSpec}, it must represent the signature of
an entire batch instead of just one example.
}
\seealso{
\itemize{
\item \url{https://keras.io/api/layers}
}
}
