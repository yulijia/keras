% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers.R
\name{layer_max_pooling_2d}
\alias{layer_max_pooling_2d}
\title{Max pooling operation for 2D spatial data}
\usage{
layer_max_pooling_2d(
  object,
  pool_size = list(2L, 2L),
  strides = NULL,
  padding = "valid",
  data_format = NULL,
  ...
)

layer_max_pooling_2d(
  object,
  pool_size = list(2L, 2L),
  strides = NULL,
  padding = "valid",
  data_format = NULL,
  ...
)
}
\arguments{
\item{pool_size}{integer or list of 2 integers,
window size over which to take the maximum.
\verb{(2, 2)} will take the max value over a 2x2 pooling window.
If only one integer is specified, the same window length
will be used for both dimensions.}

\item{strides}{Integer, list of 2 integers, or NULL.
Strides values.  Specifies how far the pooling window moves
for each pooling step. If NULL, it will default to \code{pool_size}.}

\item{padding}{One of \code{"valid"} or \code{"same"} (case-insensitive).
\code{"valid"} means no padding. \code{"same"} results in padding evenly to
the left/right or up/down of the input such that output has the same
height/width dimension as the input.}

\item{data_format}{A string,
one of \code{channels_last} (default) or \code{channels_first}.
The ordering of the dimensions in the inputs.
\code{channels_last} corresponds to inputs with shape
\verb{(batch, height, width, channels)} while \code{channels_first}
corresponds to inputs with shape
\verb{(batch, channels, height, width)}.
When unspecified, uses
\code{image_data_format} value found in your Keras config file at
\verb{~/.keras/keras.json} (if exists) else 'channels_last'.
Defaults to 'channels_last'.}

\item{...}{standard layer arguments.}
}
\description{
Max pooling operation for 2D spatial data

Max pooling operation for 2D spatial data
}
\details{
Downsamples the input along its spatial dimensions (height and width)
by taking the maximum value over an input window
(of size defined by \code{pool_size}) for each channel of the input.
The window is shifted by \code{strides} along each dimension.

The resulting output,
when using the \code{"valid"} padding option, has a spatial shape
(number of rows or columns) of:
\code{output_shape = math.floor((input_shape - pool_size) / strides) + 1}
(when \code{input_shape >= pool_size})

The resulting output shape when using the \code{"same"} padding option is:
\code{output_shape = math.floor((input_shape - 1) / strides) + 1}

For example, for \verb{strides=(1, 1)} and \code{padding="valid"}:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> x = tf.constant([[1., 2., 3.],
...                  [4., 5., 6.],
...                  [7., 8., 9.]])
>>> x = tf.reshape(x, [1, 3, 3, 1])
>>> max_pool_2d = tf.keras.layers.MaxPooling2D(pool_size=(2, 2),
...    strides=(1, 1), padding='valid')
>>> max_pool_2d(x)
<tf.Tensor: shape=(1, 2, 2, 1), dtype=float32, numpy=
  array([[[[5.],
           [6.]],
          [[8.],
           [9.]]]], dtype=float32)>
}\if{html}{\out{</div>}}

For example, for \verb{strides=(2, 2)} and \code{padding="valid"}:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> x = tf.constant([[1., 2., 3., 4.],
...                  [5., 6., 7., 8.],
...                  [9., 10., 11., 12.]])
>>> x = tf.reshape(x, [1, 3, 4, 1])
>>> max_pool_2d = tf.keras.layers.MaxPooling2D(pool_size=(2, 2),
...    strides=(2, 2), padding='valid')
>>> max_pool_2d(x)
<tf.Tensor: shape=(1, 1, 2, 1), dtype=float32, numpy=
  array([[[[6.],
           [8.]]]], dtype=float32)>
}\if{html}{\out{</div>}}

Usage Example:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> input_image = tf.constant([[[[1.], [1.], [2.], [4.]],
...                            [[2.], [2.], [3.], [2.]],
...                            [[4.], [1.], [1.], [1.]],
...                            [[2.], [2.], [1.], [4.]]]])
>>> output = tf.constant([[[[1], [0]],
...                       [[0], [1]]]])
>>> model = tf.keras.models.Sequential()
>>> model.add(tf.keras.layers.MaxPooling2D(pool_size=(2, 2),
...    input_shape=(4, 4, 1)))
>>> model.compile('adam', 'mean_squared_error')
>>> model.predict(input_image, steps=1)
array([[[[2.],
         [4.]],
        [[4.],
         [4.]]]], dtype=float32)
}\if{html}{\out{</div>}}

For example, for stride=(1, 1) and padding="same":

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> x = tf.constant([[1., 2., 3.],
...                  [4., 5., 6.],
...                  [7., 8., 9.]])
>>> x = tf.reshape(x, [1, 3, 3, 1])
>>> max_pool_2d = tf.keras.layers.MaxPooling2D(pool_size=(2, 2),
...    strides=(1, 1), padding='same')
>>> max_pool_2d(x)
<tf.Tensor: shape=(1, 3, 3, 1), dtype=float32, numpy=
  array([[[[5.],
           [6.],
           [6.]],
          [[8.],
           [9.],
           [9.]],
          [[8.],
           [9.],
           [9.]]]], dtype=float32)>
}\if{html}{\out{</div>}}

Input shape:
\itemize{
\item If \code{data_format='channels_last'}:
4D tensor with shape \verb{(batch_size, rows, cols, channels)}.
\item If \code{data_format='channels_first'}:
4D tensor with shape \verb{(batch_size, channels, rows, cols)}.
}

Output shape:
\itemize{
\item If \code{data_format='channels_last'}:
4D tensor with shape \verb{(batch_size, pooled_rows, pooled_cols, channels)}.
\item If \code{data_format='channels_first'}:
4D tensor with shape \verb{(batch_size, channels, pooled_rows, pooled_cols)}.
}

A tensor of rank 4 representing the maximum pooled values.  See above for

Downsamples the input along its spatial dimensions (height and width)
by taking the maximum value over an input window
(of size defined by \code{pool_size}) for each channel of the input.
The window is shifted by \code{strides} along each dimension.

The resulting output,
when using the \code{"valid"} padding option, has a spatial shape
(number of rows or columns) of:
\code{output_shape = math.floor((input_shape - pool_size) / strides) + 1}
(when \code{input_shape >= pool_size})

The resulting output shape when using the \code{"same"} padding option is:
\code{output_shape = math.floor((input_shape - 1) / strides) + 1}

For example, for \verb{strides=(1, 1)} and \code{padding="valid"}:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> x = tf.constant([[1., 2., 3.],
...                  [4., 5., 6.],
...                  [7., 8., 9.]])
>>> x = tf.reshape(x, [1, 3, 3, 1])
>>> max_pool_2d = tf.keras.layers.MaxPooling2D(pool_size=(2, 2),
...    strides=(1, 1), padding='valid')
>>> max_pool_2d(x)
<tf.Tensor: shape=(1, 2, 2, 1), dtype=float32, numpy=
  array([[[[5.],
           [6.]],
          [[8.],
           [9.]]]], dtype=float32)>
}\if{html}{\out{</div>}}

For example, for \verb{strides=(2, 2)} and \code{padding="valid"}:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> x = tf.constant([[1., 2., 3., 4.],
...                  [5., 6., 7., 8.],
...                  [9., 10., 11., 12.]])
>>> x = tf.reshape(x, [1, 3, 4, 1])
>>> max_pool_2d = tf.keras.layers.MaxPooling2D(pool_size=(2, 2),
...    strides=(2, 2), padding='valid')
>>> max_pool_2d(x)
<tf.Tensor: shape=(1, 1, 2, 1), dtype=float32, numpy=
  array([[[[6.],
           [8.]]]], dtype=float32)>
}\if{html}{\out{</div>}}

Usage Example:

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> input_image = tf.constant([[[[1.], [1.], [2.], [4.]],
...                            [[2.], [2.], [3.], [2.]],
...                            [[4.], [1.], [1.], [1.]],
...                            [[2.], [2.], [1.], [4.]]]])
>>> output = tf.constant([[[[1], [0]],
...                       [[0], [1]]]])
>>> model = tf.keras.models.Sequential()
>>> model.add(tf.keras.layers.MaxPooling2D(pool_size=(2, 2),
...    input_shape=(4, 4, 1)))
>>> model.compile('adam', 'mean_squared_error')
>>> model.predict(input_image, steps=1)
array([[[[2.],
         [4.]],
        [[4.],
         [4.]]]], dtype=float32)
}\if{html}{\out{</div>}}

For example, for stride=(1, 1) and padding="same":

\if{html}{\out{<div class="sourceCode python">}}\preformatted{>>> x = tf.constant([[1., 2., 3.],
...                  [4., 5., 6.],
...                  [7., 8., 9.]])
>>> x = tf.reshape(x, [1, 3, 3, 1])
>>> max_pool_2d = tf.keras.layers.MaxPooling2D(pool_size=(2, 2),
...    strides=(1, 1), padding='same')
>>> max_pool_2d(x)
<tf.Tensor: shape=(1, 3, 3, 1), dtype=float32, numpy=
  array([[[[5.],
           [6.],
           [6.]],
          [[8.],
           [9.],
           [9.]],
          [[8.],
           [9.],
           [9.]]]], dtype=float32)>
}\if{html}{\out{</div>}}

Input shape:
\itemize{
\item If \code{data_format='channels_last'}:
4D tensor with shape \verb{(batch_size, rows, cols, channels)}.
\item If \code{data_format='channels_first'}:
4D tensor with shape \verb{(batch_size, channels, rows, cols)}.
}

Output shape:
\itemize{
\item If \code{data_format='channels_last'}:
4D tensor with shape \verb{(batch_size, pooled_rows, pooled_cols, channels)}.
\item If \code{data_format='channels_first'}:
4D tensor with shape \verb{(batch_size, channels, pooled_rows, pooled_cols)}.
}

A tensor of rank 4 representing the maximum pooled values.  See above for
}
\seealso{
\itemize{
\item \url{https://keras.io/api/layers}
}

\itemize{
\item \url{https://keras.io/api/layers}
}
}
